# Жизненный цикл подов

Добро пожаловать в новый модуль! В этот раз мы поговорим о важности структурных паттернов при построении микросервисной архитектуры. Их понимание и использование так же важно, как и знание жизненного цикла пода, что является залогом стабильности и надёжности приложений.

Жизненные циклы пода определяют этапы, через которые проходят контейнеры: создание, подготовка к работе, завершение. Понимание каждого этапа позволяет управлять запуском и остановкой служб. Пробы (Liveness, Readiness, Startup-probes) помогают настраивать автоматическую проверку состояния и готовности приложений, обеспечивая их корректную работу и восстановление после сбоев.

Мы также рассмотрим разделение кода и конфигурации (Secrets и ConfigMap) для безопасного хранения чувствительных данных, таких как пароли и ключи доступа. Эти знания позволят разрабатывать устойчивые, масштабируемые и защищённые распределённые приложения.

## Состояние контейнеров

Kubernetes отслеживает состояние каждого контейнера внутри пода. Основные состояния:

- **Waiting (ожидание)** — контейнер выполняет операции перед запуском, например, загружает образ.
- **Running (работает)** — контейнер выполняется без проблем.
- **Terminated (завершён)** — контейнер завершился либо по плану, либо из-за сбоя.
- **Error** — контейнер завершился с ненулевым кодом ошибки.
- **CrashLoopBackOff** — контейнер постоянно выходит из строя и перезапускается с экспоненциальной задержкой.

Для проверки состояния контейнера используйте команду:
```sh
kubectl describe pod <pod-name>
```

Если под содержит один или несколько контейнеров, завершившихся с ошибкой, его статус будет **Failed**, а контейнер — **Error**. Для диагностики используются:
```sh
kubectl describe pod <pod-name>
kubectl logs <pod-name>
```

## Политики перезапуска (restartPolicy)

Kubernetes управляет сбоями контейнеров с помощью политики перезапуска **restartPolicy**. Возможные значения:

- **Always** (по умолчанию) — контейнер перезапускается после любого завершения.
- **OnFailure** — контейнер перезапускается только при ненулевом коде завершения.
- **Never** — контейнер не перезапускается автоматически.

Перезапуски сопровождаются экспоненциальной задержкой (10, 20, 40 секунд и т. д.), ограниченной 300 секундами (5 минут).

Если контейнер успешно работает в течение определённого времени (например, 10 минут), Kubernetes сбрасывает задержку возврата.

Чтобы проверить рестарты контейнеров, используйте:
```sh
kubectl get pods
```

## Ошибки загрузки образов

При проблемах с загрузкой образов Kubernetes может выдать статусы:

- **ErrImagePull** — ошибка при попытке загрузить образ контейнера.
- **ImagePullBackOff** — Kubernetes применяет задержку перед повторными попытками загрузки образа.

Чтобы воспроизвести ошибку:

1. В Deployment измените имя образа на несуществующее:
   ```yaml
   image: ghcr.io/stefanprodan/podinfo_my:6.6.3
   ```
2. Примените манифест:
   ```sh
   kubectl apply -f deployment_terminating.yaml
   ```
3. Проверьте статус контейнера:
   ```sh
   kubectl get pods
   ```

После тестирования верните правильный образ и примените изменения.

## Состояния подов (Pod Condition)

Отслеживать состояния пода можно с помощью:
```sh
kubectl get pod <pod-name> -o json | jq .status
```

Под проходит через несколько **conditions**:

- **PodScheduled** — под назначен на узел.
- **PodReadyToStartContainers** — создана среда пода, сеть настроена.
- **Ready** — под готов обрабатывать запросы.
- **Initialized** — все Init-контейнеры успешно выполнены.
- **Unschedulable** — под не может быть запущен из-за нехватки ресурсов.
- **ContainersReady** — все контейнеры в поде готовы.

## Журналирование событий
Kubernetes регистрирует как события (Events) планирования, 
изменения состояния контейнера и ошибки, так и события, связанные с конкретным приложением. 
При этом платформа предоставляет подробный хронологический журнал действий и изменений состояния в кластере. 
Посмотрим события нашего пода при помощи команды 
```sh
kubectl events <pod-name>
```

# Механизмы проверки работоспособности контейнеров в Kubernetes

## Проблема

Kubernetes считает контейнер запущенным, если процесс внутри него ещё работает. Однако это не означает, что приложение готово обслуживать запросы или корректно функционировать.

В этом разделе рассмотрим механизмы проверки (probes) работоспособности контейнеров в Kubernetes и разберём их типы.

## Последовательность старта пода

Если какой-то механизм (хук, Probe, Init) не сконфигурирован в манифестах, он просто будет пропускаться. Общая последовательность старта пода:

1. Запуск Sandbox-контейнера.
2. Запуск Init-контейнера.
3. Запуск Main-контейнера и `startupProbe`.
4. При запуске контейнера выполняется `PostStart`-хук (если задан).
5. Запуск `livenessProbe` и `readinessProbe`.
6. При завершении работы пода срабатывает `PreStop`-хук.
7. Завершение контейнера.

### Sandbox-контейнер

В терминологии CRI-контейнер называется Sandbox (песочница), а в Kubernetes — infrastructure или Pause-контейнер. Это базовый элемент архитектуры пода, скрытый от пользователя. Он создаёт и поддерживает необходимые ресурсы.

### Init-контейнер

Определяется пользователем и выполняет задачи инициализации приложения. Если не задан, шаг пропускается.

### Основной контейнер и проверки

- `startupProbe` — проверяет, полностью ли запущено приложение.
- `PostStart`-хук — выполняется после запуска контейнера (если определён).
- `livenessProbe` — проверяет, эффективно ли работает контейнер.
- `readinessProbe` — проверяет, готов ли контейнер к обработке запросов.
- `PreStop`-хук — срабатывает перед остановкой контейнера.

## Kubernetes и диагностика контейнеров

`kubelet` регулярно запрашивает у контейнерной среды (Container runtime) состояние контейнера и перезапускает его в случае проблем. Однако запуск процесса не означает, что приложение работает корректно.

Для решения этой проблемы Kubernetes использует механизмы проверок, которые позволяют определить, готово ли приложение к обслуживанию клиентов.

## Виды проверок

1. **Проверка работоспособности (`livenessProbe`)** — указывает, эффективно ли работает контейнер.
2. **Проверка готовности (`readinessProbe`)** — указывает, может ли контейнер обрабатывать запросы.
3. **Проверка старта (`startupProbe`)** — указывает, полностью ли запустилось приложение.

## Методы диагностики (`Handlers`)

Проверки выполняются через обработчики:

- **ExecAction** — выполняет команду внутри контейнера. Успех определяется кодом завершения `0`.
- **TCPSocketAction** — проверяет открытие TCP-порта контейнера.
- **HTTPGetAction** — выполняет HTTP-запрос `GET` и считает успешным ответ с кодом 200–399.

## Возможные результаты проверки

Каждая проверка может вернуть один из трёх результатов:

- **Success** (успех) — контейнер прошёл диагностику.
- **Failure** (сбой) — контейнер не прошёл диагностику.
- **Unknown** (неизвестно) — диагностика не удалась, но без последствий.

Эти механизмы помогают Kubernetes поддерживать стабильность приложений и автоматизировать перезапуски в случае проблем.

# Проверка работоспособности — livenessProbe

## Описание

`livenessProbe` указывает только на то, что контейнер работает, но не даёт информации о готовности приложения. Если проверка не проходит, `kubelet` завершает контейнер и перезапускает его в соответствии с политикой перезапуска.

Если `livenessProbe` не настроена, состояние контейнера по умолчанию считается успешным (`Success`). Этот механизм помогает Kubernetes определять, когда необходимо перезапустить контейнер с приложением.

## Управление проверками

На поведение проверок влияют следующие параметры (они применимы ко всем проверкам):

- **`initialDelaySeconds`** — через сколько секунд после запуска контейнера запускать проверки.
  - Если задана `startupProbe`, `livenessProbe` и `readinessProbe` не выполняются, пока она не завершится успешно.
  - Если `periodSeconds` больше, чем `initialDelaySeconds`, последний параметр игнорируется.
  - Значение по умолчанию: `0`.
  - Минимальное значение: `0`.

- **`periodSeconds`** — как часто (в секундах) выполняется проверка.
  - Значение по умолчанию: `10`.
  - Минимальное значение: `1`.
  - Проверка `readinessProbe` может выполняться с другим интервалом, если контейнер ещё не готов.

- **`timeoutSeconds`** — время ожидания проверки, после которого она считается неудачной.
  - Значение по умолчанию: `1`.
  - Минимальное значение: `1`.

- **`successThreshold`** — минимальное количество последовательных успешных проверок после сбоя, чтобы статус проверки стал успешным.
  - Значение по умолчанию: `1`.
  - Минимальное значение: `1`.
  - Для `livenessProbe` и `startupProbe` должно быть `1`.

- **`failureThreshold`** — сколько раз подряд должна завершиться проверка с ошибкой, прежде чем Kubernetes признает контейнер неработоспособным.
  - Значение по умолчанию: `3`.
  - Минимальное значение: `1`.
  - Если контейнер не проходит `failureThreshold` раз подряд, Kubernetes перезапускает его.

- **`terminationGracePeriodSeconds`** — время ожидания перед принудительным завершением контейнера при сбое.
  - По умолчанию наследуется из настроек модуля (`30` секунд, если не указано иначе).
  - Минимальное значение: `1`.

Настройка этих параметров позволяет гибко управлять поведением контейнера и его перезапусками в случае ошибок.

## Проблема

После настройки `livenessProbe` контейнер перестаёт зависать и автоматически перезапускается в случае сбоев. Однако пользователи продолжают сталкиваться с ошибками. Это связано с тем, что после перезапуска контейнер сразу начинает принимать запросы, хотя фактически приложение ещё не готово.

## Решение: readinessProbe

Проверка `readinessProbe` позволяет убедиться, что контейнер действительно готов обрабатывать запросы. В отличие от `livenessProbe`, она не перезапускает контейнер, а исключает его из списка доступных конечных точек (endpoints) сервиса до тех пор, пока проверка не пройдет успешно.

### Когда `readinessProbe` полезна:
- Приложение ещё загружается и не готово к приёму запросов.
- Приложение ожидает доступности внешней зависимости (например, базы данных).
- Контейнер перегружен, и ему нужно временно исключить себя из трафика.

### Настройка

Методы проверки (`HTTP`, `TCP`, `Exec`, `gRPC`) и временные параметры (`initialDelaySeconds`, `periodSeconds`, `failureThreshold`) аналогичны `livenessProbe`.

При сбое проверки `readinessProbe` контейнер **не перезапускается**, но Kubernetes исключает его из балансировки.

## Пример конфигурации

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: myapp-container
    image: myapp-image
    livenessProbe:
      httpGet:
        path: /healthz
        port: 8080
      initialDelaySeconds: 10
      periodSeconds: 5
      failureThreshold: 3
    readinessProbe:
      httpGet:
        path: /readiness
        port: 8080
      initialDelaySeconds: 5
      periodSeconds: 5
      failureThreshold: 1
```

### Разбор конфигурации

- `readinessProbe` проверяет `/readiness` перед тем, как контейнер начнёт принимать запросы.
- `livenessProbe` проверяет `/healthz` и отвечает за перезапуск контейнера в случае сбоя.
- `failureThreshold: 1` для `readinessProbe` означает, что единственная ошибка исключит под из балансировки.
- `failureThreshold: 3` для `livenessProbe` означает, что контейнер будет перезапущен после трёх неудачных проверок.

## Потенциальные проблемы

### 1. Чрезмерно жёсткие параметры `readinessProbe`
Если `failureThreshold` настроен слишком низко (`1`), контейнер может быть исключён из балансировки даже при кратковременных сбоях, что приведёт к перебоям в обслуживании.

### 2. Чрезмерно чувствительная `livenessProbe`
Если `livenessProbe` настроена слишком агрессивно, Kubernetes может посчитать контейнер "мёртвым" и начать его перезапуск. Это приведёт к каскадной перезагрузке множества подов.

## Возможная каскадная перезагрузка:
1. `readinessProbe` начинает выдавать ошибки из-за нагрузки, под помечается как `NotReady`.
2. `livenessProbe` быстро распознаёт контейнер как "мёртвый" и перезапускает его.
3. Перезапуск пода приводит к повторной инициализации приложения, базы данных и других зависимостей.
4. Это создаёт дополнительную нагрузку, которая может вызвать сбои в других подах.
5. Цикл повторяется, вызывая "каскадный шторм" перезапусков.

# Проверка старта — startupProbe

## Проблема

После настройки `readinessProbe` Kubernetes перестал направлять трафик на неподготовленные контейнеры. Однако при высоких нагрузках или обновлениях базы данных приложение стартует медленно. В результате `livenessProbe` и `readinessProbe` завершают проверку с ошибкой, и Kubernetes перезапускает контейнер, считая его "мёртвым", хотя на самом деле он просто долго инициализируется.

## Решение: startupProbe

`startupProbe` позволяет дать контейнеру дополнительное время на запуск, прежде чем Kubernetes начнёт проверять его с помощью `livenessProbe` и `readinessProbe`. Это особенно полезно в случаях:
- Длительная загрузка данных или инициализация приложения.
- Запуск тяжёлых процессов перед началом обработки запросов.
- Развёртывание больших приложений.

## Как работает `startupProbe`

- Пока `startupProbe` не завершится успешно, Kubernetes **не выполняет** `livenessProbe` и `readinessProbe`.
- Если `startupProbe` проходит успешно, далее контейнер начинает работать по обычному сценарию с `livenessProbe` и `readinessProbe`.
- Если контейнер не проходит `startupProbe`, Kubernetes считает его "неживым" и перезапускает.

## Пример конфигурации

```yaml
startupProbe:
  exec:
    command:
      - podcli
      - check
      - http
      - localhost:9000/healthz
  initialDelaySeconds: 1
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1
  periodSeconds: 10
```

### Разбор параметров

- `exec` — выполняет команду внутри контейнера (`podcli check http localhost:9000/healthz`).
- `initialDelaySeconds: 1` — задержка перед первой проверкой.
- `timeoutSeconds: 5` — время ожидания ответа.
- `failureThreshold: 3` — если три проверки подряд завершатся с ошибкой, контейнер будет перезапущен.
- `successThreshold: 1` — одного успешного результата достаточно, чтобы завершить `startupProbe`.
- `periodSeconds: 10` — частота выполнения проверки (раз в 10 секунд).

## Совместное использование с другими проверками

Можно задать все три проверки (`startupProbe`, `livenessProbe`, `readinessProbe`) в одном манифесте (`deployment_probes.yaml`).

После применения манифеста можно проверить статус проверок:
```sh
kubectl describe pod <pod_name>
```

## Итог
- `startupProbe` позволяет контейнеру инициализироваться без преждевременного перезапуска.
- После успешного завершения `startupProbe` Kubernetes начинает использовать `livenessProbe` и `readinessProbe`.
- Настройка всех трёх проверок вместе даёт более гибкий контроль над состоянием приложения.

# Kubernetes и механизмы проверки

## Добавление startupProbe

Добавив `startupProbe` и настроив его на 60 секунд, приложение теперь стабильно инициализируется перед запуском проверок `livenessProbe` и `readinessProbe`. Это помогло избежать преждевременных перезапусков и стабилизировало работу.

---

## Как Kubernetes использует механизмы проверки

Механизмы `livenessProbe`, `readinessProbe` и `startupProbe` активно применяются в следующих процессах:

### 1. Пошаговое обновление (Rolling Update)

Пошаговое обновление — стратегия обновления подов, при которой старые поды заменяются новыми без простоев.

- `readinessProbe` проверяет, готов ли новый под принимать запросы, предотвращая маршрутизацию трафика на неподготовленные поды.
- `livenessProbe` гарантирует, что зависшие или неисправные поды будут автоматически перезапущены.
- Если новый под успешно проходит `readinessProbe`, Kubernetes начинает направлять на него трафик, а затем переходит к обновлению следующего пода.

### 2. Масштабирование подов (увеличение числа реплик)

При увеличении числа реплик Kubernetes запускает новые поды, но не направляет на них трафик, пока они не пройдут `readinessProbe`. Это:
- Гарантирует, что только полностью инициализированные поды начинают обработку запросов.
- Предотвращает ошибки, связанные с отправкой запросов на неподготовленные поды.

### 3. Масштабирование подов (уменьшение числа реплик)

При уменьшении числа реплик Kubernetes сначала проверяет состояние подов:
- Поды, которые больше не должны обрабатывать трафик, помечаются как "не готовые" (`NotReady`).
- Kubernetes перестаёт направлять к ним новые запросы, но позволяет завершить активные сессии.
- После завершения всех запросов под безопасно удаляется, предотвращая потерю данных.

### 4. Освобождение узла (Drain)

При освобождении узла Kubernetes перемещает запущенные на нём поды на другие узлы.
- Поды на освобождаемом узле помечаются как `NotReady`, поэтому Kubernetes перестаёт направлять к ним новый трафик.
- Активные сессии продолжают выполняться до завершения.
- После успешного переноса на новые узлы поды проходят проверку `readinessProbe` и только затем начинают принимать трафик.

---

## Проверки Kubernetes

Проверки в Kubernetes — это механизмы мониторинга состояния контейнеров. Они помогают Kubernetes определять, когда приложение работает корректно, а когда его нужно перезапустить или временно исключить из обработки трафика.

### 1. `readinessProbe`
Используется для проверки готовности пода к обработке запросов. Позволяет убедиться, что трафик направляется только на полностью готовые поды, что критично при обновлениях и масштабировании.

### 2. `livenessProbe`
Отвечает за проверку жизнеспособности пода. Позволяет Kubernetes перезапускать контейнеры, если они зависли или перестали корректно работать.

### 3. `startupProbe`
Используется для приложений с длительной инициализацией. Позволяет избежать преждевременных перезапусков `livenessProbe`, пока под ещё загружается.

## Итог

- `readinessProbe` предотвращает отправку трафика на неготовые поды и защищает приложение при обновлениях и масштабировании.
- `livenessProbe` автоматически перезапускает зависшие поды, способствуя самовосстановлению приложения.
- `startupProbe` позволяет приложениям дольше инициализироваться без преждевременных перезапусков.
- Комбинация всех трёх механизмов делает приложения в Kubernetes надёжными и отказоустойчивыми.
- Однако настройка проверок требует внимательности, чтобы избежать каскадных перезапусков и других нежелательных эффектов.

# Управление жизненным циклом подов в Kubernetes

## Контроль работоспособности и управление подами

В предыдущем уроке мы обсудили API-интерфейсы для проверки работоспособности приложений (`livenessProbe`, `readinessProbe`, `startupProbe`). Эти механизмы помогают Kubernetes оценивать состояние приложения, но они не всегда достаточны для управления жизненным циклом подов.

Kubernetes предоставляет контракты и ограничения, которые помогают приложениям корректно работать в кластере. Одним из ключевых элементов являются **сигналы и хуки жизненного цикла**, которые позволяют управлять запуском и завершением контейнеров.

---

## Сигналы в Kubernetes

В UNIX-системах сигналы используются для управления процессами. Kubernetes применяет этот механизм для уведомления контейнеров о необходимости завершения работы.

### **Сигнал SIGTERM**

Первый сигнал, который Kubernetes отправляет при завершении работы пода — **SIGTERM**. Этот сигнал позволяет приложению:
- Закрыть открытые соединения.
- Сохранить критические данные.
- Корректно завершить активные транзакции.

Если приложение обрабатывает SIGTERM, оно может выполнить необходимые действия перед завершением работы.

### **Сигнал SIGKILL**

Если контейнер не завершил работу после получения SIGTERM, Kubernetes принудительно завершает процесс с помощью **SIGKILL**. По умолчанию перед SIGKILL даётся **30 секунд** (`terminationGracePeriodSeconds`), но этот интервал можно изменить.

Принудительное завершение SIGKILL предотвращает зависание контейнеров, но оно не даёт приложению шанса на корректное завершение работы.

---

## Хуки жизненного цикла контейнеров

Хуки в Kubernetes позволяют выполнять команды в определённые моменты жизненного цикла контейнера. Это даёт дополнительный контроль над запуском и завершением контейнера.

### **1. Хук `postStart`**

`postStart` вызывается после создания контейнера, но до его готовности к работе. Он может использоваться для:
- Инициализации сервисов и соединений.
- Подготовки кеша.
- Регистрации контейнера в системе.

Пример настройки `postStart` в манифесте:
```yaml
containers:
  - name: podinfo
    lifecycle:
      postStart:
        exec:
          command:
            - /bin/sh
            - -c
            - sleep 20 && echo "Finished postStart!" > /home/app/message
```

Хук `postStart` выполняется асинхронно с запуском основного контейнера и может блокировать его готовность до завершения выполнения команды.

### **2. Хук `preStop`**

`preStop` вызывается перед завершением контейнера и работает аналогично SIGTERM. Он используется для:
- Освобождения ресурсов.
- Закрытия соединений с базами данных.
- Выполнения завершающих операций перед выключением контейнера.

Пример `preStop` в манифесте:
```yaml
containers:
  - name: podinfo
    lifecycle:
      preStop:
        exec:
          command:
            - /bin/sh
            - -c
            - echo 'Received STOP signal. Cleaning up...' > /proc/1/fd/1;
            - sleep 5;
            - echo 'Cleanup complete. Shutting down.' > /proc/1/fd/1
terminationGracePeriodSeconds: 10  
```

`preStop` выполняется перед SIGTERM и даёт возможность подготовить контейнер к корректному завершению.

---

## Как Kubernetes завершает под

1. **Вызывается `preStop` (если настроен).**
2. **Отправляется SIGTERM.**
3. **Ждётся `terminationGracePeriodSeconds`.**
4. **Если контейнер не завершил работу — отправляется SIGKILL.**

Настройка корректного завершения работы контейнера помогает избежать потерь данных, зависших транзакций и ошибок пользователей.

---

## Итог

- **SIGTERM** и `preStop` позволяют приложениям корректно завершать работу.
- **SIGKILL** предотвращает зависание контейнеров.
- **postStart** гарантирует, что сервисы полностью подготовлены перед обработкой запросов.
- Корректное управление жизненным циклом контейнеров предотвращает каскадные сбои и потери данных.

# Структурные паттерны в Kubernetes

## Зачем нужны структурные паттерны?

Базовые сущности Kubernetes, такие как `Deployment` и `Service`, предоставляют фундаментальные возможности для управления приложениями, но не содержат чёткой структуры или шаблонов проектирования. Это приводит к:
- Разрозненности кодовой базы.
- Дублированию логики.
- Увеличению времени на поддержку инфраструктуры.

Для унификации и упрощения проектирования надёжных и масштабируемых систем применяются **структурные паттерны Kubernetes**.

### Основные структурные паттерны:
1. **Init Container** — контейнеры инициализации.
2. **Sidecar** — вспомогательные контейнеры.
3. **Adapter** — преобразование данных.
4. **Ambassador (Reverse Proxy)** — проксирование запросов.

---

## Паттерн Init Container

Некоторые приложения требуют выполнения определённых операций перед запуском, например:
- Подготовка конфигурации.
- Миграция базы данных.
- Проверка доступности внешних сервисов.
- Загрузка секретов или настроек.

Выполнение этих задач в основном контейнере может усложнить код и создать дополнительные зависимости. `Init Container` позволяет вынести эти операции в отдельные контейнеры, которые выполняются **до старта основного контейнера**.

### Как работает Init Container?

- Init-контейнер запускается **перед основными контейнерами**.
- Все Init-контейнеры **выполняются последовательно**.
- Если Init-контейнер завершился с ошибкой, Kubernetes **не запустит основной контейнер**.
- Основной контейнер стартует **только после успешного завершения всех Init-контейнеров**.

### Пример манифеста с Init-контейнерами:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: sequential-init-containers-pod
spec:
  initContainers:
  - name: init-container-1
    image: busybox
    command: ["sh", "-c", "echo 'Init Container 1: Preparing environment'; sleep 5"]
    resources:
      requests:
        memory: "20Mi"
        cpu: "120m"
      limits:
        memory: "100Mi"
        cpu: "320m"

  - name: init-container-2
    image: busybox
    command: ["sh", "-c", "echo 'Init Container 2: Loading configuration'; sleep 5"]
    resources:
      requests:
        memory: "20Mi"
        cpu: "120m"
      limits:
        memory: "100Mi"
        cpu: "320m"

  - name: init-container-3
    image: busybox
    command: ["sh", "-c", "echo 'Init Container 3: Finalizing setup'; sleep 5"]
    resources:
      requests:
        memory: "20Mi"
        cpu: "120m"
      limits:
        memory: "100Mi"
        cpu: "320m"

  containers:
  - name: main-app
    image: busybox
    command: ["sh", "-c", "echo 'Main Application: Running...'; sleep 3600"]
    resources:
      requests:
        memory: "20Mi"
        cpu: "120m"
      limits:
        memory: "100Mi"
        cpu: "320m"
```

### Разбор манифеста:
1. **Init-контейнеры выполняются последовательно:**
   - `init-container-1` выполняет подготовку среды.
   - `init-container-2` загружает конфигурацию.
   - `init-container-3` завершает установку.
2. **Основной контейнер (`main-app`) запускается только после завершения всех Init-контейнеров.**
3. **Если хотя бы один Init-контейнер завершится с ошибкой, основной контейнер не запустится.**

### Важные особенности Init Container:
- **Init-контейнеры не используют `livenessProbe`, `readinessProbe` или `startupProbe`** — они должны завершиться успешно, иначе основной контейнер не стартует.
- **Init-контейнеры используют ресурсы (`CPU`, `Memory`), но после завершения их ресурсы освобождаются.**
- **Init-контейнеры могут работать в одном поде с основными контейнерами**, но имеют **отдельный жизненный цикл**.
- **Планирование ресурсов:**
  - Kubernetes берёт максимальные запрашиваемые ресурсы среди Init-контейнеров и основных контейнеров для расчёта потребления пода.

---

## Итог

- **Init Container** — полезный паттерн для выполнения операций перед запуском основного контейнера.
- Позволяет **разделить логику инициализации** и основное приложение.
- Init-контейнеры **выполняются последовательно** и должны успешно завершиться.
- Если Init-контейнер завершается с ошибкой, **основной контейнер не стартует**.
- **Планирование ресурсов** Kubernetes учитывает Init-контейнеры при расчёте требований к поду.

Использование Init-контейнеров позволяет улучшить надёжность и управляемость приложений в Kubernetes.

# Структурные паттерны Kubernetes: Sidecar, Adapter и Ambassador

## Паттерн Sidecar

Если ваше основное приложение нуждается в дополнительной функциональности (например, логирование, кэширование или мониторинг), но вы не хотите изменять его код, подойдёт **паттерн Sidecar**. Этот подход позволяет **расширить функциональность** приложения без вмешательства в его кодовую базу.

### Основные идеи Sidecar:
- Один контейнер решает **одну проблему**.
- Контейнер можно легко **заменять и повторно использовать**.
- Позволяет **разделить ответственность** между процессами.
- Основное приложение остаётся **изолированным** от дополнительных функций.

### Примеры использования:
1. **Sidecar для мониторинга и логирования**: сбор логов или метрик с основного контейнера.
2. **Sidecar для кэширования данных**: кэширование с использованием Redis или Memcached.
3. **Sidecar для отладки и тестирования**: захват сетевого трафика для анализа (например, Wireshark).
4. **Sidecar для отказоустойчивости**: дополнительный контейнер проверяет работоспособность основного и инициирует перезапуск при сбоях.

### Пример Sidecar-контейнера:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: simple-sidecar
spec:
  containers:
  - name: main-app
    image: busybox
    command: ["sh", "-c", "echo 'Main app is running'; while true; do date; sleep 5; done"]
  - name: simple-sidecar
    image: busybox
    command: ["sh", "-c", "echo 'Sidecar is running'; while true; do echo 'Sidecar: checking main app status...'; ps aux | grep 'main app'; sleep 5; done"]
```

### Возможные сценарии сбоев:
- **Sidecar-контейнер завершился, но основной контейнер работает** → Sidecar перезапускается автоматически, если настроена соответствующая политика.
- **Sidecar-контейнер завис, а основной контейнер зависит от него** → основной контейнер может столкнуться с тайм-аутами или сбоями.
- **Sidecar-контейнер постоянно перезапускается (CrashLoopBackOff)** → весь под может стать неработоспособным.

---

## Паттерн Adapter

Если ваше приложение использует **устаревшие API** или интерфейсы, несовместимые с новыми системами, но менять его код рискованно, подойдёт **паттерн Adapter**. Он позволяет **преобразовывать данные** между разными интерфейсами.

### Где используется Adapter:
- **CSI-драйверы**: переводят команды Kubernetes в формат внешних систем хранения.
- **Ingress-контроллеры**: проксируют HTTP-запросы и маршрутизируют их.
- **Адаптация нестандартных форматов данных**: преобразование логов или метрик в нужный формат.

### Пример использования:
Если приложение собирает метрики в текстовом формате, а система мониторинга принимает только JSON, Adapter-контейнер преобразует данные в нужный формат.

Другой пример — старое приложение использует устаревшие команды Redis, а сервер Redis обновился. Adapter-контейнер может транслировать старые команды в новый формат.

---

## Паттерн Ambassador (Reverse Proxy)

Если приложение **должно взаимодействовать с внешними сервисами**, но вам нужно **изолировать** эту логику, подойдёт **паттерн Ambassador**. Он действует как **прокси** между приложением и внешними API.

### Основные задачи Ambassador:
- Проксирование запросов к удалённым сервисам.
- Повторная отправка запросов в случае ошибок.
- Локальное кеширование ответов API.
- Стабилизация соединения с внешними базами данных.

### Примеры использования:
1. **Envoy как Ambassador** → управляет сетевыми запросами и балансирует нагрузку.
2. **Ретраи запросов** → если внешний сервис временно недоступен, Ambassador повторяет запрос.
3. **Маршрутизация API-запросов** → например, микросервис отправляет HTTP-запросы через Ambassador, который адаптирует их для разных API.

### Отличие от Sidecar:
- **Sidecar** расширяет функциональность приложения.
- **Ambassador** выполняет роль интеллектуального **прокси**.

---

## Таблица сравнения паттернов

| Характеристика          | Паттерн Sidecar | Паттерн Adapter | Паттерн Ambassador |
|-------------------------|----------------|-----------------|--------------------|
| **Назначение**         | Расширение функциональности (логирование, мониторинг и т. д.) основного приложения. | Адаптация интерфейсов между Kubernetes и внешними системами. | Проксирование запросов к внешним системам. |
| **Пример использования** | Логирование, мониторинг, кеширование. | Интеграция с внешними системами через CRD/Операторы. | Прокси для взаимодействия с внешними API. |
| **Взаимодействие с внешними системами** | Нет непосредственного взаимодействия с внешними системами. | Адаптирует внутренние ресурсы Kubernetes к внешним API. | Основное взаимодействие с внешними API. |
| **Где применяется** | В поде для добавления дополнительных функций. | Часто используется в контроллерах или операторах для адаптации внешних API. | Используется в поде для взаимодействия с внешними системами через прокси. |
| **Уровень взаимодействия** | Тесная связь с основным контейнером. | Адаптация конфигураций, API или данных. | Взаимодействие с внешними сервисами в качестве прокси. |

---

## Итог
- **Sidecar** расширяет возможности приложения без изменения кода.
- **Adapter** делает несовместимые компоненты совместимыми.
- **Ambassador** проксирует запросы к внешним сервисам.
- Комбинация этих паттернов повышает отказоустойчивость и управляемость приложений в Kubernetes.

# Механизмы для отделения конфигурации от кодовой базы в Kubernetes

## Зачем отделять конфигурацию от кода?

Приложение может работать в разных средах (development, testing, production), каждая из которых имеет свои настройки. Например:
- Подключение к разным базам данных.
- Использование различных API-ключей и токенов.
- Разные уровни логирования.

Отделение конфигурации позволяет:
- Изменять настройки **без пересборки** контейнера.
- Разворачивать **тот же самый контейнер** в разных средах.
- Управлять конфигурацией централизованно.

## Основные механизмы управления конфигурацией в Kubernetes

### 1. **Переменные окружения (Environment Variables)**
Используются для передачи простых параметров, таких как порты, идентификаторы или пути к ресурсам.

**Пример:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: example-pod
spec:
  containers:
  - name: my-app-container
    image: alpine:latest
    command: ["/bin/sh", "-c"]
    args:
    - |
      echo "APP_ENV: $APP_ENV";
      echo "LOG_LEVEL: $LOG_LEVEL";
      tail -f /dev/null
    env:
    - name: APP_ENV
      value: "production"
    - name: LOG_LEVEL
      value: "info"
```

**Плюсы:**
- Простота использования.
- Гибкость при развертывании.

**Минусы:**
- Не подходят для хранения конфиденциальных данных.
- Значения загружаются только при запуске контейнера.

---

### 2. **ConfigMap** — хранение неконфиденциальных данных
ConfigMap используется для централизованного хранения параметров, которые могут использовать несколько подов.

**Пример:**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-config
data:
  APP_ENV: "production"
  LOG_LEVEL: "debug"
```

#### Использование ConfigMap в поде (через переменные окружения):
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: example-pod
spec:
  containers:
  - name: my-app-container
    image: alpine:latest
    command: ["/bin/sh", "-c"]
    args:
    - |
      echo "App env: $APP_ENV";
      echo "Log level: $LOG_LEVEL";
      tail -f /dev/null
    env:
    - name: APP_ENV
      valueFrom:
        configMapKeyRef:
          name: my-config
          key: APP_ENV
    - name: LOG_LEVEL
      valueFrom:
        configMapKeyRef:
          name: my-config
          key: LOG_LEVEL
```

#### Использование ConfigMap как файла (монтирование в том):
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-app-pod
spec:
  containers:
  - name: test-container
    image: alpine:latest
    command: ["/bin/sh", "-c"]
    args:
    - |
      cat /etc/test/test.conf;
      tail -f /dev/null
    volumeMounts:
    - name: config-volume
      mountPath: /etc/test/test.conf
      subPath: test.conf
  volumes:
  - name: config-volume
    configMap:
      name: my-config
      items:
      - key: test.conf
        path: test.conf
```

**Плюсы:**
- Централизованное управление конфигурацией.
- Возможность динамически изменять файлы конфигурации.

**Минусы:**
- Изменения в ConfigMap не обновляют переменные окружения в работающих подах.

---

### 3. **Secrets** — безопасное хранение конфиденциальных данных
Используются для хранения паролей, API-ключей, токенов и сертификатов.

**Пример секрета:**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  username: YWRtaW4=          # base64("admin")
  password: MWYyZDFlMmU2N2Rm  # base64("mypassword123")
```

#### Использование Secret в поде (как переменные окружения):
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-pod
spec:
  containers:
  - name: app-container
    image: alpine
    command: ["/bin/sh", "-c", "echo 'User: $USERNAME'; echo 'Password: $PASSWORD'; sleep 3600"]
    env:
    - name: USERNAME
      valueFrom:
        secretKeyRef:
          name: my-secret
          key: username
    - name: PASSWORD
      valueFrom:
        secretKeyRef:
          name: my-secret
          key: password
```

#### Использование Secret как тома (монтирование в файловую систему):
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-volume-pod
spec:
  containers:
  - name: app-container
    image: alpine
    command: ["/bin/sh", "-c", "ls /etc/secret-volume && sleep 3600"]
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/secret-volume
  volumes:
  - name: secret-volume
    secret:
      secretName: my-secret
```

**Плюсы:**
- Данные передаются в **защищённом виде**.
- Можно ограничить доступ к секретам с помощью **RBAC**.
- Секреты хранятся **зашифрованными в etcd** (при включённом шифровании).

**Минусы:**
- По умолчанию кодируются **base64**, а не шифруются (требуется включать дополнительное шифрование).

---

## Итог

| Механизм  | Что хранит? | Где хранится? | Способы использования |
|-----------|------------|--------------|-----------------------|
| **Переменные окружения** | Простые строки | В манифесте пода | Передача конфигурации через `env` |
| **ConfigMap** | Неконфиденциальные данные | В объекте Kubernetes | Через `env`, монтирование в том, аргументы командной строки |
| **Secret** | Конфиденциальные данные (пароли, токены) | В зашифрованном etcd | Через `env`, монтирование в том |

### **Ключевые выводы:**
- **ConfigMap** используется для хранения **обычных** конфигураций.
- **Secret** используется для **чувствительных** данных.
- **Переменные окружения** — простой способ передачи параметров в контейнер.
- **Монтирование файлов из ConfigMap/Secret** даёт больше гибкости.
- **RBAC и шифрование в etcd** обеспечивают безопасное хранение секретов.

Теперь можно легко управлять конфигурацией Kubernetes-приложений без изменения кода!

